/*
Copyright (c) 2024  Blue Robotics

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/*
 * A Schema to demonstrate common features
 */

/*
 * Define the packet header.
 * This occurs at the start of all packets
 */
define Packet block {
	uint32 preamble //A packet must start with this exact value
	uint16 length  //the length of the packet in words
	/* a CRC-16 CCITT(0xffff) for packet error detection
	 * this is computed on all words of the packet beyond the header
	 * this is only necessary to check if the transport method
	 * does not have error detection mechanism
	 */
	uint16 crc
}
/* 
 * This is the top level hierarchy of a BR packet
 */
Packet brPacket(preamble = 0x45554c42) {
	/*
	 * Now the payload header
	 * every block within a packet needs to follow this form.
	 * Note that the structure is the same as an array, but the repeats field is not used
	 */
	define Payload block {
		uint16 key
		uint8 length //the length of the payload in 4-byte words
		uint8 repeats //this will always be zero for a block
	}
	
	/*
	 * This is the header for an array
	 */
	define Array array {
		uint16 key //a unique identifier of this block
		uint8 length //the length of one unit of this block
		uint8 repeats //this indicates the number units of this block. This will always be >= 1. If the array is empty then it won't be included in the block
	}

	/* this section conveys the ID of the device
	 * this a unique identifier
	 * any payload following an ID payload is assumed only to be
	 * to or from that particular device.
	 * A device will always send an ID payload with every packet.
	 * A bus controller does not need to send an ID payload.
	 * A packet without one shall still be processed by a peripheral
	 */
	Payload idPayload(key = 0x0000) {
		uint32 id
	}
	/**
	 * a request by the bus controller to all devices that have not communicated successfully recently
	 * the controller can specify the probability and timeframe that the peripherals will respond
	 * the peripherals will respond with an idPayload
	 */
	Payload whosTherePayload(key = 0x0002) {
		float32 probability //the probability that the peripheral will respond. 1.0 is 100% probability, 0.0 is zero.
		float32 time //the time in seconds within which the device should respond.
	}
	
	/*
	 * A payload for a peripheral to convey its details to the controller.
	 * A controller requests a version payload by sending an empty one.
	 */
	Payload versionPayload(key = 0x0001) {
	
		uint32 fw //this is the version of the firmware
	
		// this defines the type of hardware (i.e. type/purpose of PCB)
		define HwDef compound {
			define HwType enum uint16 {
				UNDEFINED   = 0xffff
				SFDQ      	= 0x0000
				BLUE_SERVO	= 0x0001
				LUMEN       = 0x0002
				NUCLEO     	= 0x0003 //the ST family of development PCBs
				BLUE_ESC	= 0x0004
			}
			
			define McuType enum uint8 {
				UNDEFINED = 0xff
				STM32F446 = 0x01
				STM32H563 = 0x02
				STM32H573 = 0x03
				STM32G071 = 0x04
			}
			HwType hwType
			uint8 hwRev
			McuType mcuType
			
			
		
		}
		HwDef hwDef //this allocates a field of the hardware definition compound type
	}
	/*
     * a payload for conveying ADC values and configuring the adc
     * the controller can send this with configuration parameters
     * the peripheral can send this with adc values and/or config parameters
	 */
	Array adcValuesArray {
		float32 value
	}
	Array adcConfigArray {
		float32 timeConstantSeconds
		float32 gain
		float32 offset
	}
	
	Payload TimePayload {
		uint32 hostTime //time in milliseconds from program start according to the bus controller
		uint32 localTime //time in milliseconds from program start according to sender of this packet
	}
	/*
	 * A payload for configuring a servo
	 */
	Payload servoConfigPayload {
		bool positionNotVelocity //when true causes servo to control its rotational position, otherwise controls rotational velocity
		float32 maxPos //maximum target - servo will not allow position to go above this. This is either as a position or a velocity depending on positionNotVelocity
		float32 minPos //minimum target - servo will not allow position to go below this. This is either a position or a velocity depending on positionNotVelocity
		/*
		 * applies a gain to the servo setpoint and actual. Default values are radians for position and radians per second for velocity.
		 * Gain multiplies these values. i.e. 57.3 would mean working in degrees instead of radians
		 */
		float32 gain  
	}
	/*
	 * A payload for controlling a servo and also for the response from a servo
	 */
	Payload servoControlPayload {
		float32 setpoint //this is the target that the servo will attempt to achieve. This is either a rotational position or a speed, depending on configuration
	}
	/*
	 * A payload for the response from a sero
	 */
	 Payload servoResponsePayload {
	 	float32 actualPosition
	 	float32 actualVelocity
	 }
	
	/*
	 * A payload for controlling a lumen
	 * A lumen will response with a lumenResponsePayload
	 */
	Payload lightControlPayload {
		float32 setpoint //this is the light control setpoint for the lumen. It is normalizeed so that a value of 1.0 is full brightness and 0.0 is off
	}

	/*
	 * A payload for the response from a lumen
	 */
	Payload lightResponsePayload {
		float32 actualPower //this is the power being delivered to the LED in Watts. 
		float32 temperature //this is the temperature of the light.
	}
	/*
	 * this sends a new setpoint to the ESC.
	 */
	Payload escControlPayload {
		float32 setpoint //this is the desired velocity setpoint of the ESC in rad/s
	}
	/*
	 * A response from an ESC reporting on a few things of interest
	 */
	Payload escResponsePayload {
		float32 actual //this is the actual velocity of the ESC in rad/s
		float32 current //this is the total current in Amps
		float32 volts //this is the measured supply voltage
	}
	/**
	 * A family of payloads for uploading new firmware to a peripheral
	 * All data arrays must be preceeded by a flashProgramPayload
	 * The peripheral will respond with a program payload to indicate progress
	 * The state indicates requests from the bus controller or responses from the peripheral
	 */
	Payload flashProgramPayload {
		define FlashProgramState enum uint8 {
			DO_NOTHING_REQUEST     =  0  //controller doesn't want the peripheral to do anything in particular at this moment

		
			UPLOAD_REQUEST         =  1  //controller is sending upload data to the peripheral
			RUN_REQUEST            =  2  //controller wants peripheral to run the image in flash. Only should work if peripheral has a good image
			OVERWRITE_REQUEST      =  3  //controller wants peripheral to overwrite its main code with the new flash image. Image must be good for this to be accepted
			CLEAR_REQUEST          =  4  //controller wants peripheral to clear its upper flash memory in preparation for an upload. This will only be complied with if the peripheral is either in image good or image bad state
		
			IMAGE_GOOD_RESPONSE    =  5  //peripheral has a good image in flash
			IMAGE_BAD_RESPONSE     =  6  //peripheral has data in flash that does not check out as a correct image
			IMAGE_CLEAR_RESPONSE   =  7  //peripheral indicates that its upper flash memory is clear and ready for upload
			UPLOADING_RESPONSE     =  8  //peripheral is receiving data.
			UPLOAD_BAD_RESPONSE    =  9  //peripheral detected an error in the data - controller should stand by and wait for it to resolve. Peripheral will clear the bad sector and respond with an uploading response when ready
			WILL_RUN_RESPONSE      = 10  //peripheral responds with this for 5 packet cycles, then reboots
			RUNNING_RESPONSE       = 11  //peripheral is running upper flash image
			OVERWRITING_RESPONSE   = 12  //peripheral response with this for 5 packet cyles, then reboots.
			CLEARING_RESPONSE      = 13  //peripheral says that it's busy clearing
			
			
		}
		FlashProgramState state
		uint32 version
		uint32 crc //a crc of the words sent so far. This is an ethernet CRC-32
		uint32 start //the number of words transferred so far, and the start index of the next array of data. Peripherals will indicate the total words that have passed CRC here.
		uint32 end //the number of words that will have been transferred after the following array. This is also the index of the first element of the array after this one. Peripherals will indicate the total number of words received here.
		uint32 length //the total number of words that will be transferred. When length equals total length then the transfer is complete
		/*
		 * an array of 32 bit words of data. A series of these payloads sent over time will make up the total new firmware
		 * each program array must be preceeded by a flash program payload to indicate where to place the array to build the entire new 
		 */
		Array flashProgramArray { 
			uint32 data //little endian data - LSB is the lowest address, comes first
		}
	}
	/*
	 * Conveys an arbitrary array of floats to or from a peripheral.
	 * The meaning of this data is known to the firmware but is not specified.
	 * Primarily used for debugging and development 
	 */
	Array appDataArray {
		float32 data
	}
	/*
	 * Feedback module setpoints are defined as trajectory waypoints
	 * They are defined by a value and a rate of value change at a specific time in the future
	 * Many setpoints can be queued to for a piecewise continuous path for the controller to follow
	 * The feedback module will compute a cubic equation to traverse from one waypoint to another 
	 */
	Array feedbackTrajectoryArray {
		uint8 channel //the feedback channel that this payload is to update the trajectories of
		float32 setpoint //the target value that the feedback controller should achieve
		float32 setpointRate //the target rate of setpoint change that should be achieved when the setpoint is achieved
		uint32 time //the time by which the setpoint and setpoint rate should be acheived. This is in milliseconds of "host time"
	}
	/*
	 * A peripheral responds with this when receiving a trajectory array
	 */
	
	/*
	 * A payload for a peripheral to indicate the state of its feedback control modules 
	 */
	Array feedbackResponseArray {
		float32 actual
		float32 setpoint
		float32 output
		uint8 queueLength //the number of items in the queue
		uint32 endTime //the time when the last trajectory in the queue will end
	}
	/*
	 * This configures a feedback channel
	 * the peripheral will respond with the same paylaod
	 * if the payload is sent empty then it only triggers the peripheral to respond with its configuration
	 * One payload is sent per feedback channel used
	 * These do not need to be sent regularly
	 */
	Payload feedbackConfigPayload {
		uint8 channel //the channel to configure
		//A selection of units for the setpoint.
		//Mostly just to select between angular units and units that do not loop
		//For now this is not inteded to stray beyond SI
		define Unit enum uint8 {
			METRES = 0
			RADIANS = 1
			METRES_PER_SECOND = 3
			RADIANS_PER_SECOND = 4
		}
		Unit unit
		bool enable //enable this channel
		float32 minInput
		float32 maxInput
		float32 minOutput
		float32 maxOutput
		/*
		 * Defines where the feedback controller should get its input from
		 */
		define PlumbingType enum uint8 {
			UNCONFIGURED = 0
			OPEN_LOOP = 1
			TX_APP_DATA = 2
			RX_APP_DATA = 3
			STREAM = 4
		}
	
		PlumbingType inputType
		PlumbingType outputType
		uint8 inputChannel //selects the channel to get the input from of the type specified in the inputType field, only if channel number makes sense
		uint8 outputChannel
		float32 c0
		float32 c1
		float32 c2
		float32 d1
		float32 d2
	}
	Array thermistorArray {
		float32 celsius
	}
	
	
			
			

}
