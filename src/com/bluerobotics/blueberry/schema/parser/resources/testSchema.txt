/*
Copyright (c) 2024  Blue Robotics

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/*
 * A Schema to demonstrate common features
 */

/*
 * Define the packet header.
 * This occurs at the start of all packets
 */
define Packet block {
	uint32 preamble //A packet must start with this exact value
	uint16 length  //the length of the packet in words
	/* a CRC-16 CCITT(0xffff) for packet error detection
	 * this is computed on all words of the packet beyond the header
	 * this is only necessary to check if the transport method
	 * does not have error detection mechanism
	 */
	uint16 crc
}
/* 
 * This is the top level hierarchy of a BR packet
 */
Packet brPacket(preamble = 0x45554c42) {
	/*
	 * Now the payload header
	 * every block within a packet needs to follow this form.
	 * Note that the structure is the same as an array, but the repeats field is not used
	 */
	define Payload block {
		uint16 key
		uint8 length //the length of the payload in 4-byte words
		uint8 repeats //this will always be zero for a block
	}
	
	/*
	 * This is the header for an array
	 */
	define Array array {
		uint16 key //a unique identifier of this block
		uint8 length //the length of one unit of this block
		uint8 repeats //this indicates the number units of this block. This will always be >= 1. If the array is empty then it won't be included in the block
	}

	/* this section conveys the ID of the device
	 * this a unique identifier
	 * any payload following an ID payload is assumed only to be
	 * to or from that particular device.
	 * A device will always send an ID payload with every packet.
	 * A bus controller does not need to send an ID payload.
	 * A packet without one shall still be processed by a peripheral
	 */
	Payload idPayload(key = 0x0000) {
		uint32 id
	}
	/**
	 * a request by the bus controller to all devices that have not communicated successfully recently
	 * the controller can specify the probability and timeframe that the peripherals will respond
	 * the peripherals will respond with an idPayload
	 */
	Payload whosTherePayload(key = 0x0002) {
		float32 probability //the probability that the peripheral will respond. 1.0 is 100% probability, 0.0 is zero.
		float32 time //the time in seconds within which the device should respond.
	}
	
	/*
	 * A payload for a peripheral to convey its details to the controller.
	 * A controller requests a version payload by sending an empty one.
	 */
	Payload versionPayload(key = 0x0001) {
	
		uint32 fw //this is the version of the firmware
	
		// this defines the type of hardware (i.e. type/purpose of PCB)
		define HwDef compound {
			define HwType enum uint16 {
				UNDEFINED   = 0xffff
				SFDQ      	= 0x0000
				BLUE_SERVO	= 0x0001
				LUMEN       = 0x0002
				NUCLEO     	= 0x0003 //the ST family of development PCBs
				BLUE_ESC	= 0x0004
			}
			
			define McuType enum uint8 {
				UNDEFINED = 0xff
				STM32F446 = 0x01
				STM32H563 = 0x02
				STM32H573 = 0x03
				STM32G071 = 0x04
			}
			HwType hwType
			uint8 hwRev
			McuType mcuType
			
			
		
		}
		HwDef hwDef //this allocates a field of the hardware definition compound type
	}
	/*
     * a payload for conveying ADC values and configuring the adc
     * the controller can send this with configuration parameters
     * the peripheral can send this with adc values and/or config parameters
	 */
	Array adcValuesArray {
		float32 value
	}
	Array adcConfigArray {
		float32 timeConstantSeconds
		float32 gain
		float32 offset
	}
	
	Payload TimePayload {
		uint32 hostTime //time in milliseconds from program start according to the bus controller
		uint32 localTime //time in milliseconds from program start according to sender of this packet
	}
	/*
	 * A payload for configuring a servo
	 */
	Payload servoConfigPayload {
		bool positionNotVelocity //when true causes servo to control its rotational position, otherwise controls rotational velocity
		float32 maxPos //maximum target - servo will not allow position to go above this. This is either as a position or a velocity depending on positionNotVelocity
		float32 minPos //minimum target - servo will not allow position to go below this. This is either a position or a velocity depending on positionNotVelocity
		/*
		 * applies a gain to the servo setpoint and actual. Default values are radians for position and radians per second for velocity.
		 * Gain multiplies these values. i.e. 57.3 would mean working in degrees instead of radians
		 */
		float32 gain  
	}
	/*
	 * A payload for controlling a servo and also for the response from a servo
	 */
	Payload servoControlPayload {
		float32 setpoint //this is the target that the servo will attempt to achieve. This is either a rotational position or a speed, depending on configuration
	}
	/*
	 * A payload for the response from a sero
	 */
	 Payload servoResponsePayload {
	 	float32 actualPosition
	 	float32 actualVelocity
	 }
	
	/*
	 * A payload for controlling a lumen
	 * A lumen will response with a lumenResponsePayload
	 */
	Payload lumenControlPayload {
		float32 setpoint //this is the light control setpoint for the lumen. It is normalizeed so that a value of 1.0 is full brightness and 0.0 is off
	}

	/*
	 * A payload for the response from a lumen
	 */
	Payload lumenResponsePayload {
		float32 actualPower //this is the power being delivered to the LED in Watts. 
		float32 temperature //this is the temperature of the light.
	}
	Payload escControlPayload {
		float32 setpoint //this is the desired velocity setpoint of the ESC in rad/s
	}
	Payload escResponsePayload {
		float32 actual //this is the actual velocity of the ESC
		float32 current //this is the total current in Amps
		float32 volts //this is the measured supply voltage
	}
	/**
	 * A family of payloads for uploading new firmware to a peripheral
	 * All data arrays must be preceeded by a flashProgramPayload
	 * The peripheral will respond with a program payload to indicate progress
	 * 
	 */
	Payload flashProgramPayload {
		define FlashProgramState enum uint8 {
			IDLE = 0 //this means there is nothing happening and nothing desired to happen
			UPLOAD = 1 //this means a FW codebase is being transferred to the peripheral
			THREE = 2 //the first step to trigger either running or programming of the new code
			TWO = 3 //the second step
			ONE = 4 //the final step before either running or programming
			RUN = 5 //triggers the peripheral to run a newly uploaded codebase. Must be preceeded by THREE, TWO, ONE
			PROGRAM = 6 //triggers the peripheral to copy a newly uploaded codebase into its base memory. Must be preceeded by THREE, TWO, ONE
			CHECK_FAIL = 7 //indicates that the peripheral computed an incorrect check code on the data received so far 
		}
		FlashProgramState state
		uint32 version
		uint32 hash //a check code of the total codebase
		uint32 address //the address of the first word of the upcoming data, a peripheral will respond with the next available address after all data transferred so far
		/*
		 * an array of 32 bit words of data. A series of these payloads sent over time will make up the total new firmware
		 * each program array must be preceeded by a flash program payload to indicate where to place the array to build the entire new 
		 */
		Array flashProgramArray { 
			uint32 data //little endian data - LSB is the lowest address, comes first
		}
	}
	/*
	 * Conveys an arbitrary array of floats to or from a peripheral.
	 * The meaning of this data is known to the firmware but is not specified.
	 * Primarily used for debugging and development 
	 */
	Array appDataArray {
		float32 data
	}

}
